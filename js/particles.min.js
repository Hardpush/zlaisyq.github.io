// 简化版 particles.js - 用于本地运行
(function() {
  'use strict';
  
  window.particlesJS = function(tagId, params) {
    // 先检查tagId是否为字符串
    if (typeof tagId !== 'string') {
      console.error('particlesJS: tagId must be a string');
      return;
    }
    
    // 获取目标元素
    const targetElement = document.getElementById(tagId);
    let canvas;
    
    // 如果目标元素不存在
    if (!targetElement) {
      console.error('particlesJS: cannot find element with id:', tagId);
      // 创建一个div容器
      const container = document.createElement('div');
      container.id = tagId;
      container.style.position = 'fixed';
      container.style.top = '0';
      container.style.left = '0';
      container.style.width = '100%';
      container.style.height = '100%';
      container.style.pointerEvents = 'none';
      document.body.insertBefore(container, document.body.firstChild);
      return window.particlesJS(tagId, params); // 重新调用
    }
    
    // 如果目标元素是canvas，直接使用
    if (targetElement instanceof HTMLCanvasElement) {
      canvas = targetElement;
    } else {
      // 如果目标元素不是canvas，在其中创建一个canvas元素
      console.log('particlesJS: target is not a canvas, creating canvas inside:', tagId);
      // 检查是否已存在canvas子元素
      let existingCanvas = targetElement.querySelector('canvas');
      if (existingCanvas && existingCanvas instanceof HTMLCanvasElement) {
        canvas = existingCanvas;
      } else {
        // 创建新的canvas元素
        canvas = document.createElement('canvas');
        canvas.style.display = 'block';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        // 清空容器并添加canvas
        targetElement.innerHTML = '';
        targetElement.appendChild(canvas);
      }
    }
    
    // 确保canvas具有getContext方法
    if (!canvas || typeof canvas.getContext !== 'function') {
      console.error('particlesJS: canvas element does not support getContext');
      return;
    }
    
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('particlesJS: failed to get 2d context');
      return;
    }
    
    let particles = [];
    let animationId = null;
    
    // 设置画布尺寸
    function setCanvasSize() {
      canvas.style.position = canvas.style.position || 'fixed';
      canvas.style.top = canvas.style.top || '0';
      canvas.style.left = canvas.style.left || '0';
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.zIndex = canvas.style.zIndex || '-1';
      
      // 设置实际canvas尺寸以匹配显示尺寸
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    
    // 简化的配置处理
    function getConfig() {
      // 兼容不同格式的配置对象
      const config = {
        particles: {
          number: { value: 80 },
          color: { value: '#ff8096' },
          speed: { value: 1 },
          size: { value: 2 },
          line_linked: {
            color: '#994dff',
            width: 1
          }
        },
        interactivity: {
          detect_on: 'canvas'
        }
      };
      
      // 合并用户配置
      if (params && typeof params === 'object') {
        Object.assign(config.particles, params.particles || {});
        Object.assign(config.interactivity, params.interactivity || {});
      }
      
      return config;
    }
    
    const config = getConfig();
    
    // 创建粒子
    function createParticles() {
      particles = [];
      const particleCount = config.particles.number.value;
      const color = config.particles.color.value;
      const size = config.particles.size.value;
      
      // 获取canvas显示尺寸（不是实际像素尺寸）
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;
      
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * displayWidth,
          y: Math.random() * displayHeight,
          radius: Math.random() * size + 1,
          color: color,
          speedX: (Math.random() - 0.5) * (config.particles.speed.value),
          speedY: (Math.random() - 0.5) * (config.particles.speed.value)
        });
      }
    }
    
    // 绘制粒子
    function drawParticles() {
      particles.forEach(particle => {
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fillStyle = particle.color;
        ctx.fill();
        ctx.closePath();
      });
    }
    
    // 更新粒子位置
    function updateParticles() {
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;
      
      particles.forEach(particle => {
        particle.x += particle.speedX;
        particle.y += particle.speedY;
        
        // 边界检查
        if (particle.x < 0 || particle.x > displayWidth) particle.speedX *= -1;
        if (particle.y < 0 || particle.y > displayHeight) particle.speedY *= -1;
      });
    }
    
    // 绘制连接线
    function drawLines() {
      const connectDistance = 100;
      
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const dx = particles[i].x - particles[j].x;
          const dy = particles[i].y - particles[j].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < connectDistance) {
            ctx.beginPath();
            ctx.strokeStyle = config.particles.line_linked.color;
            ctx.lineWidth = config.particles.line_linked.width;
            ctx.globalAlpha = 1 - distance / connectDistance;
            ctx.moveTo(particles[i].x, particles[i].y);
            ctx.lineTo(particles[j].x, particles[j].y);
            ctx.stroke();
            ctx.closePath();
            ctx.globalAlpha = 1;
          }
        }
      }
    }
    
    // 动画循环
    function animate() {
      ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
      updateParticles();
      drawParticles();
      drawLines();
      animationId = requestAnimationFrame(animate);
    }
    
    // 初始化
    function init() {
      setCanvasSize();
      createParticles();
      animate();
      
      window.addEventListener('resize', () => {
        setCanvasSize();
      });
    }
    
    init();
    
    // 返回API对象
    return {
      destroy: () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
      }
    };
  };
})();